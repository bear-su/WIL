# 클린아키텍처

코드는 `순차`, `분기`,`반복`의 집합체 

소프트웨어 아키텍처의 규칠이란 프로그램의 구성요소를 정렬하고 조립하는 방법에 대한 규칙 

### Ch1. 설계와 아키텍처란
> 소프트웨어 아키텍처의 목표는 필요한 시스템을 만들고 유지보수하는 데 투입되는 인력을 최소화하는 데 있다. 

느린 것 같아도 제대로 개발했을 때가 결국엔 더 빠른 개발 속도를 가진다. 


### Ch2. 두 가지 가치에 대한 이야기

모든 소프트웨어는 `행위`와 `구조`라는 서로 다른 두 가치를 시스템 이해관계자에게 제공한다. 
#### 행위 
- 기계가 수익을 창출하거나 비용을 절약하도록 만들기 위해서, 요구사항을 기계에 구현하고 버그를 수정한다. 

#### 아키텍처 (구조)
이해관계자가 기능에 대한 생각을 바꾸면, 이러한 변경사항을 간단하고 쉽게 적용할 수 있어야 한다. 
변경사항을 적용하는 데 드는 어려움은 변경되는 범위에 비례해야 하며 변경사항의 형태와는 관련이 없어야 한다? 이게 무슨 말인가?
아키텍처는 형태에 독립적이어야 하고, 그럴수록 더 실용적이다. 

보통 상황에서는 `아키텍처 > 행위 `가 성립한다. 

### Ch3. 패러다임
패러다임이란 프로그래밍을 하는 방법으로, 대체로 언어에는 독립적이다.

#### 구조적 프로그래밍 
> 제어 흐름의 직접적인 전환을 규제하는 방식입니다. 예를 들어, 프로그램의 각 부분이 순차적으로 실행되도록 하고, 조건문이나 반복문을 사용하여 제어 흐름을 명확하게 합니다.

#### 객체지향 프로그래밍 
> 객체와 클래스 개념을 통해 프로그램의 구조를 잡는 방식입니다. 객체 간의 메시지 전달을 통해 상호작용하며, 이를 통해 프로그램의 흐름을 관리합니다. 예를 들어, 자동차를 객체로 만들고, 가속이나 제동과 같은 동작을 메서드로 정의할 수 있습니다.

#### 함수형 프로그래밍
> 데이터 변경을 최소화하고, 상태 변화를 피하는 방식입니다. 이 패러다임에서는 변수를 변경하지 않고, 순수 함수(동일한 입력에 대해 항상 동일한 출력을 반환하는 함수)를 사용하여 데이터를 처리합니다. 예를 들어, 기존 데이터를 변경하는 대신 새로운 데이터를 생성하여 반환합니다.

이런 패러다임은 아키텍처와 긴밀한 연관관계를 갖는다. 

다형성을 활용하여 서로 다른 아키텍처 경계를 넘나들며, 함수형 프로그래밍을 사용하여 데이터의 위치와 접근 방법에 대한 규칙을 정할 수 있다. 또 구조적 프로그래밍을 통해 모듈의 기본 알고리즘을 설계할 수 있습니다.



Goto 문장이 모듈을 더 작은 단위로 재귀적으로 분해하는 과정에 방해가 되며, 모듈을 분해할 수 없다면 합리적으로 증명할 때 필수적인 기법인 분할 정복 접근법을 사용할 수 없게 된다. 
goto문장을 사용하더라도 모듈을 분해할 때 문제가 되지 않는 경우도 있었는데 이런 경우가 if/then/else와 do/while과 같은 분기와 반복이라는 단순한 제어 구조에 해당함. 
이러한 종류의 제어 구조만 사용하면 증명 가능한 단위로까지 모듈울 재귀적으로 세분화할 수 있음 


#### 기능적 분해
- 구조적 프로그래밍을 통해 모듈을 증명 가능한 더 작은 단위로 재귀적으로 분해할 수 있게 되었고 결국은 모듈을 기능적으로 분해할 수 있게됨. 
프로그램은 과학과 같다. 증명 가능한 서술이 거짓임을 입증하는 원리 . 서술된 내용이 사실임을 증명하는 방식이 아니라 서술이 틀렸음을 증명하는 방식으로 동작 
프로그램이 잘못되었음을 테스트를 통해 증명할 수는 있찌만 맞다고 증명할 수는 없다. 구조적 프로그래밍은 프로그램을 증명 가능한 세부 기능 집합으로 재귀적으로 분해하고 테스트를 통해 증명 가능한 세부 기능들이 거짓인지를 증명하려고 시도한다. 
- 거짓임을 증명하려는 테스트가 실패한다면, 이기능들은 목표에 부합할 만큼은 충분히 참이다. 
- 즉 구조적 프로그래밍은 프로그래밍에서 반증 가능한 단위를 만들어 낼 수 있는 가치를 준다. 반증 가능성에 의해 주도됨. 


#### 객체지향 프로그래밍
 객체지향에서 중요한 세 가지 원칙을 캡슐화, 상속, 다형성이라고 한다.
 하지만 캡슐화, 상속은 이전 세대 C 아니 그 이전세대에서도 존재했다.
 
결국엔 다형성이 굉장히 중요하며, 소프트웨어 아키텍트는 다형성을 이용해서 소스 코드 의존성을 원하는 방향으로 설정할 수 있도록 해야한다. (의존성 역전) 
다형성을 통해 배포 독립성과 개발 독립성을 가질 수 있다. 


#### 함수형 프로그래밍
자바는 가변 변수를 사용하기 때문에 프로그램 실행 중에 상태가 변할 수 있다. 하지만 함수형 언어에서는 가변 변수가 전혀 없으며 변수는 변경되지 않는다.
경합 조건 (race), 교착상태, 동시 업데이트 문제가 모두 가변 변수로 인해 발생한다. 따라서 동시성 문제에 많은 관심을 기울여야 하는데 이런 불변성이 실현 가능한지도 체크해봐야 한다.

타협을 위해 가변 컴포넌트와 불변 컴포넌트로 분리해야 한다. 불변 컴포넌트는 순수하게 함수형 방식으로만 작업이 처리되며, 어떤 가변 변수도 사용되지 않는다. 불변 컴포넌트와 
하나 이상의 순수 함수형 컴포넌트가 아닌 하나 이상의 다른 컴포넌트와 서로 통신한다. 

### SOLID
#### SCP 단일 책임 원칙
> 하나의 모듈은 오직 하나의 목적에 대해서만 책임져야 한다.

#### 개방 폐쇄 원칙
> 소프트웨어는 개방에는 열려 있고, 변경에는 닫혀 있어야 한다. 
시스템을 컴포넌트 단위로 분리하고, 저수준 컴포넌트에서 발생한 변경으로부터 고수준 컴포넌트를 보호할 수 있는 형태의 의존성 계층구조가 만들어지도록 해야 한다.

#### 리스코프 치환 원칙
>

정사각형/직사각형 문제
```UML
USER --> Rectangle
            |
            |
            |
          Square
```

Rectangle의 높이와 너비는 서로 독립적으로 변경될 수 있지만 Square는 그렇지 않다. 
따라서 LSP 위반을 막기 위해 if문 등을 이용해서 Rectangle이 실제로는 Square인지를 검사하는 매커니즘을 User에 추가해야 하는데 
이렇게 되면 User의 행위가 사용하는 타입에 의존하게 된다. 

상속 관계에서 타입을 치환할 수 있도록 아키텍쳐를 설계해야 한다.


#### ISP
> 

- 필요 이상으로 많은 걸 포함하는 모듈에 의존하는 것은 해로운 일이다.

#### DIP
> 의존성이 추상에 의존하며 구체에는 의존하지 않는 시스템 
- 의존하지 않도록 피하고자 하는 것은 변동성이 큰 구체적인 요소일 뿐 
- String 클래스는 구현 클래스임에도 불구하고 매우 안정적


## 컴포넌트 
- 컴포넌트는 배포 단위. 자바의 .jar와 같음. 잘 설계된 컴포넌트라면 반드시 독립적으로 배포 가능해야 한다.


소프트웨어 개발 초창기에는 메모리에서의 프로그램 위치와 레이아웃을 프록르ㅐ머가 직접 제어했다. 그래서 프로그램을 로드할 메모리의 위치를 정해야했고, 위치가 한 번 결정되면
재배치가 불가능했다. 컴파일러는 소스 코드 전체를 여러 번에 걸쳐서 읽어야 했지만, 메모리가 너무 작아서 소ㅡ 코드 전체를 메모리에 상주시킬 수 없다는 문제가 있었음. 
컴파일러는 느린 장치를 이용해서 소스 코드를 여러 차례 읽음. 그런데 함수 라이브러리가 커지면서 시간이 점점 더 오래걸렸고 이를 해결하기 위해 함수 라이브러리의 소스 코드를 애플리케이션 코드로부터 분리했다. 
그런데 이 방법은 지속 가능하지 않다는 문제가 있었다. (애플리케이션 또는 함수가 커지면서 추가 공간을 계속 할당해야함)

이를 해결하기 위해 재배치가 가능한 바이너리를 이용. 지능적인 로더를 사용해서 메모리에 재배치할 수 있는 형태의 바이너리를 생성하도록 컴파일러를 수정한다. 함수 라이브러리를 로드할 위치와 애플리케이션을 로드할 위치를 로더에게 지시할 수 이
ㅆ게 됨. (링킹 로더의 등장) 

링킹 로더의 등장으로 프록르ㅐ머는 프로그램을 개별적으로 컴파일하고 로드할 수 있는 단위로 분할할 수 있게 됨. 하지만 프로그램이 점점 커지면서 시간이 오래걸렸고 마침내 로드와 링크가 두 단계로 분리되었음. 
프로그래머가 느린 부분 즉, 링크 과정을 맡았는데 링커라는 별도의 애플리케이션으로 이 작업을 처리하도록 만들었음. 링커는 링크가 완료된 재배치 코드를 만들어 주었고 그 덕분에 로드이 로딩 괒어이 빨라짐. 

이후 디스크가 점점 작아지고 빨라지면서 다수의 .jar파일 또는 다수의 공유 라이브러리를 순식간에 서로 링크한 후 링크가 끝난 프로그램을 실행할 수 있게 되었음. 이렇게 컴포넌트 프로그인 아키텍처가 탄생했다. 


### 컴포넌트의 응집도 
1. REP: 재사용/릴리스 등가 원칙
- 재사용 단위는 릴리스 단위와 같다. 

클래스와 모듈을 단일 컴포넌트로 묶는 방법을 제대로 설명하기 힘들기에 다음 두 원칙을 도입. 
2. CCP: 공통 폐쇄 원칙
- 동일한 이유로 동일한 시점에 변경되는 클래스를 같은 컴포넌트로 묶어라. 서로 다른 시점에 다른 이유로 변경되는 클래스는 다른 컴포넌트로 분리하라. 

3. CRP: 공통 재사용 원칙
- 컴포넌트 사용자들을 필요하지 않은 것에 의존하게 강요하지 말라. 

#### 컴포넌트 응집도에 대한 균형 다이어그램 
- 응집도에 관한 세원칙이 서로 상충된다. 
- REP와 ccp는 포함 원칙 -> 컴포넌트를 크게 만든다.
- CRP - 배제 원칙 컴포넌트를 작게 만든다. 

아키텍트라면 이 원칙들이 균형을 이루는 방법을 찾아야 한다. 


### 컴포넌트 결합
#### ADP: 의존성 비순환 원칙
> 컴포넌트 의존성 그래프에 순환이 있어서는 안 된다.

- 내가 하는 작업이 다른 사람의 작업에 영향을 미치면 안 된다.

이를 해결하기 위한 방법
1. 주 단위 빌드
   - 5일 중 4일 동안 개발자는 자유롭게 개발하고 마지막 날 통합과 관련된 작업을 하는 것
   - 4일 동안 고립된 작업 환경을 보장한다.
   - 프로그램이 커지면서 하루 만에 빌드하기가 어려워지고 이는 생산성 저하로 이루어진다.
2. 순환 의존성 제거하기
   - 개발 환경을 릴리스 가능한 컴포넌트 단위로 분리하기
   - 컴포넌트를 릴리스 할 때 번호를 부여하고, 다른 팀에서 사용할 수 있도록 하며, 즉시 반영할 필요가 없다면 각 팀에서 통합하는 작업의 시점을 정할 수 있다. 

순환이 컴포넌트 의존성 그래프에 미치는 영향
- 내 코드 변경의 범위가 다른 개발자의 코드에도 영향을 미친다.
- 단위 테스트를 실행할 때 조차도 많은 라이브러리와 다른 사람의 작업물을 포함해야 한다.

이를 위해 순환을 끊고 의존성을 다시 DAG로 원상복구할 필요가 있다.
1. 의존성 역전 원칙을 적용한다.
2. 두 컴포넌트 사이에 두 컴포넌트가 모두 의존하는 새로운 컴포넌트를ㄹ 만든다. 

#### SDP: 안정된 의존성 원칙
> 더 안정된 쪽에 의존하라

변경되기 어려운 모듈이 변경되기 쉬운 모듈에 의존하게 되면 쉬운 모듈로 변경이 어려워진다. 따라서 안정된 의존성 원칙을 준수할 필요가 있다. 
- 안정성은 변경을 만들기 위해 필요한 작업량과 관련된다. (옆면으로 선 동전이 안정적이지 않은 이유는 그다지 힘을 쓰지 안혹도 넘어뜨릴 수 있기 때문)

컴포넌트 안쪽으로 들어오는 의존성이 많아지면 상당히 안정적이다. (A, B, C 컴포넌트가 D 컴포넌트를 사용하고 있을 때 D컴포넌트를 세 컴포넌트를 책임진다라고 말하며 변경하지 ㅁ랑아야 할 이유를 세 가지 가진다고 생각하면 된다. )
만약 D컴포넌트가 A,B,C에 의존하고 있다면 변경이 발생할 수 있는 외부 요인이 세 가지를 가지는 것이다. 

(다이어그램을 그릴 때는 불안정한 컴포넌트를 위쪽에 둔다)


#### SAP 안정된 추상화 원칙
> 컴포넌트는 안정된 정도만큼만 추상화되어야 한다. 

시스템에서 고수준 아키텍처나 정책 결정과 관련된 소프트웨어는 절대 자주 변경해서는 안 된다. 따라서 고수준 정책을 캡슐화하는 소프트웨어는 반드시 안정된 컴포넌트에 위치해야 하는데 그 정책을 포함하는 소스 코드는 수정하기가 어려워진다. 
컴포넌트가 최고로 안정된 상태이면서도 동시에 변경에 충분히 대응할 수 있을 정도로 유연하게 만들기 위해서 OCP원칙을 이용할 수 있다. 추상 클래스가 이 원칙을 준수한다. 

안정된 추상화 원칙은 안정성과 추상화 정도 사이의 관계를 정의한다. 
계산 코드 (132p ~ 138p)


## 아키텍처
> 아키텍처의 궁긍적인 목표는 시스템의 수명과 관련된 비용은 최소화하고, 프로그래머의 생산성은 최대화하는 데 있다.

소프트웨어를 부드럽게 유지하는 방법은 선택사항을 가능한 한 많이, 그리고 오랫동안 열어 두는 것이다. 열어 둬야 할 선택사항은 중요치 않은 세부사항이다. 

모든 소프트웨어 시스템은 주요한 두 가지 구성요소로 분해할 수 있다. 
1. 정책: 모든 업무 규칙과 업무 절차를 구체화한다. 
2. 세부사항: 사람, 외부, 시스템, 프로그래머가 정책과 소통할 때 필요한 요소지만, 정책이 가진 행위에는 조금도 영향을 미치지 않는다. (입출력 장치, 데이터베이스, 웹 시스템, 서버, 프레임워크 등 )

- 데이터베이스 시스템을 선택할 필요가 없다 -> 계층형인지 분산형인ㅈ와는 관련이 없도록 만들어야 한다. (how?)
- REST를 적용할 필요 없다. 고수준의 정책은 외부 세계로의 인터페이스에 대해 독립적이어야 하기 때문이다. 



