# 클린아키텍처

코드는 `순차`, `분기`,`반복`의 집합체 

소프트웨어 아키텍처의 규칠이란 프로그램의 구성요소를 정렬하고 조립하는 방법에 대한 규칙 

### Ch1. 설계와 아키텍처란
> 소프트웨어 아키텍처의 목표는 필요한 시스템을 만들고 유지보수하는 데 투입되는 인력을 최소화하는 데 있다. 

느린 것 같아도 제대로 개발했을 때가 결국엔 더 빠른 개발 속도를 가진다. 


### Ch2. 두 가지 가치에 대한 이야기

모든 소프트웨어는 `행위`와 `구조`라는 서로 다른 두 가치를 시스템 이해관계자에게 제공한다. 
#### 행위 
- 기계가 수익을 창출하거나 비용을 절약하도록 만들기 위해서, 요구사항을 기계에 구현하고 버그를 수정한다. 

#### 아키텍처 (구조)
이해관계자가 기능에 대한 생각을 바꾸면, 이러한 변경사항을 간단하고 쉽게 적용할 수 있어야 한다. 
변경사항을 적용하는 데 드는 어려움은 변경되는 범위에 비례해야 하며 변경사항의 형태와는 관련이 없어야 한다? 이게 무슨 말인가?
아키텍처는 형태에 독립적이어야 하고, 그럴수록 더 실용적이다. 

보통 상황에서는 `아키텍처 > 행위 `가 성립한다. 

### Ch3. 패러다임
패러다임이란 프로그래밍을 하는 방법으로, 대체로 언어에는 독립적이다.

#### 구조적 프로그래밍 
> 제어 흐름의 직접적인 전환을 규제하는 방식입니다. 예를 들어, 프로그램의 각 부분이 순차적으로 실행되도록 하고, 조건문이나 반복문을 사용하여 제어 흐름을 명확하게 합니다.

#### 객체지향 프로그래밍 
> 객체와 클래스 개념을 통해 프로그램의 구조를 잡는 방식입니다. 객체 간의 메시지 전달을 통해 상호작용하며, 이를 통해 프로그램의 흐름을 관리합니다. 예를 들어, 자동차를 객체로 만들고, 가속이나 제동과 같은 동작을 메서드로 정의할 수 있습니다.

#### 함수형 프로그래밍
> 데이터 변경을 최소화하고, 상태 변화를 피하는 방식입니다. 이 패러다임에서는 변수를 변경하지 않고, 순수 함수(동일한 입력에 대해 항상 동일한 출력을 반환하는 함수)를 사용하여 데이터를 처리합니다. 예를 들어, 기존 데이터를 변경하는 대신 새로운 데이터를 생성하여 반환합니다.

이런 패러다임은 아키텍처와 긴밀한 연관관계를 갖는다. 

다형성을 활용하여 서로 다른 아키텍처 경계를 넘나들며, 함수형 프로그래밍을 사용하여 데이터의 위치와 접근 방법에 대한 규칙을 정할 수 있다. 또 구조적 프로그래밍을 통해 모듈의 기본 알고리즘을 설계할 수 있습니다.



Goto 문장이 모듈을 더 작은 단위로 재귀적으로 분해하는 과정에 방해가 되며, 모듈을 분해할 수 없다면 합리적으로 증명할 때 필수적인 기법인 분할 정복 접근법을 사용할 수 없게 된다. 
goto문장을 사용하더라도 모듈을 분해할 때 문제가 되지 않는 경우도 있었는데 이런 경우가 if/then/else와 do/while과 같은 분기와 반복이라는 단순한 제어 구조에 해당함. 
이러한 종류의 제어 구조만 사용하면 증명 가능한 단위로까지 모듈울 재귀적으로 세분화할 수 있음 


#### 기능적 분해
- 구조적 프로그래밍을 통해 모듈을 증명 가능한 더 작은 단위로 재귀적으로 분해할 수 있게 되었고 결국은 모듈을 기능적으로 분해할 수 있게됨. 
프로그램은 과학과 같다. 증명 가능한 서술이 거짓임을 입증하는 원리 . 서술된 내용이 사실임을 증명하는 방식이 아니라 서술이 틀렸음을 증명하는 방식으로 동작 
프로그램이 잘못되었음을 테스트를 통해 증명할 수는 있찌만 맞다고 증명할 수는 없다. 구조적 프로그래밍은 프로그램을 증명 가능한 세부 기능 집합으로 재귀적으로 분해하고 테스트를 통해 증명 가능한 세부 기능들이 거짓인지를 증명하려고 시도한다. 
- 거짓임을 증명하려는 테스트가 실패한다면, 이기능들은 목표에 부합할 만큼은 충분히 참이다. 
- 즉 구조적 프로그래밍은 프로그래밍에서 반증 가능한 단위를 만들어 낼 수 있는 가치를 준다. 반증 가능성에 의해 주도됨. 


#### 객체지향 프로그래밍
 객체지향에서 중요한 세 가지 원칙을 캡슐화, 상속, 다형성이라고 한다.
 하지만 캡슐화, 상속은 이전 세대 C 아니 그 이전세대에서도 존재했다.
 
결국엔 다형성이 굉장히 중요하며, 소프트웨어 아키텍트는 다형성을 이용해서 소스 코드 의존성을 원하는 방향으로 설정할 수 있도록 해야한다. (의존성 역전) 
다형성을 통해 배포 독립성과 개발 독립성을 가질 수 있다. 


#### 함수형 프로그래밍
자바는 가변 변수를 사용하기 때문에 프로그램 실행 중에 상태가 변할 수 있다. 하지만 함수형 언어에서는 가변 변수가 전혀 없으며 변수는 변경되지 않는다.
경합 조건 (race), 교착상태, 동시 업데이트 문제가 모두 가변 변수로 인해 발생한다. 따라서 동시성 문제에 많은 관심을 기울여야 하는데 이런 불변성이 실현 가능한지도 체크해봐야 한다.

타협을 위해 가변 컴포넌트와 불변 컴포넌트로 분리해야 한다. 불변 컴포넌트는 순수하게 함수형 방식으로만 작업이 처리되며, 어떤 가변 변수도 사용되지 않는다. 불변 컴포넌트와 
하나 이상의 순수 함수형 컴포넌트가 아닌 하나 이상의 다른 컴포넌트와 서로 통신한다. 

### SOLID
#### SCP 단일 책임 원칙
> 하나의 모듈은 오직 하나의 목적에 대해서만 책임져야 한다.

#### 개방 폐쇄 원칙
> 소프트웨어는 개방에는 열려 있고, 변경에는 닫혀 있어야 한다. 
시스템을 컴포넌트 단위로 분리하고, 저수준 컴포넌트에서 발생한 변경으로부터 고수준 컴포넌트를 보호할 수 있는 형태의 의존성 계층구조가 만들어지도록 해야 한다.

#### 리스코프 치환 원칙
>

정사각형/직사각형 문제
```UML
USER --> Rectangle
            |
            |
            |
          Square
```

Rectangle의 높이와 너비는 서로 독립적으로 변경될 수 있지만 Square는 그렇지 않다. 
따라서 LSP 위반을 막기 위해 if문 등을 이용해서 Rectangle이 실제로는 Square인지를 검사하는 매커니즘을 User에 추가해야 하는데 
이렇게 되면 User의 행위가 사용하는 타입에 의존하게 된다. 

상속 관계에서 타입을 치환할 수 있도록 아키텍쳐를 설계해야 한다.


#### ISP
> 

- 필요 이상으로 많은 걸 포함하는 모듈에 의존하는 것은 해로운 일이다.

#### DIP
> 의존성이 추상에 의존하며 구체에는 의존하지 않는 시스템 
- 의존하지 않도록 피하고자 하는 것은 변동성이 큰 구체적인 요소일 뿐 
- String 클래스는 구현 클래스임에도 불구하고 매우 안정적

